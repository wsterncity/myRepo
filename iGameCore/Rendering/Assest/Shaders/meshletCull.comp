#version 460
#extension GL_ARB_bindless_texture : require

layout (local_size_x = 256) in;

// Camera buffer
layout(std140, binding = 0) uniform MVPMatrix {
    mat4 model;
    mat4 normal;
    mat4 viewproj;
} mvp;

// Meshlets Buffer
struct MeshletData {
    vec4 spherebounds;
    vec4 extents;
};
layout(std430, binding = 1) buffer MeshletsBuffer {
    MeshletData meshlets[];
};

// Indirect command buffer
struct DrawElementsIndirectCommand {
    uint count;
    uint primCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};
layout(std430, binding = 2) buffer DrawCommandBuffer {
    DrawElementsIndirectCommand commands[];
};

// Draw Cull Data
layout(std140, binding = 3) uniform DrawCullDataBlock {
    mat4 view;
    float P00, P11, znear, zfar;// symmetric projection parameters
    vec4 frustum;// data for left/right/top/bottom frustum planes
    float pyramidWidth, pyramidHeight;// depth pyramid size in texels
} drawCullData;

// hierarchical z-buffer
uniform uvec2 depthPyramid;

float LinearizeDepth(float depth)
{
    float near = drawCullData.znear;
    float far = drawCullData.zfar;
    float z = depth * 2.0 - 1.0;// back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool ProjectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
    //    if (C.z < r + znear)
    //    return false;

    vec2 cx = -C.xz;
    vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
    vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
    vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

    vec2 cy = -C.yz;
    vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
    vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
    vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

    aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
    aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f);// clip space -> uv space

    return true;
}

// Function to perform occlusion culling
bool IsVisible(MeshletData meshlet) {
    vec4 sphereBounds = meshlet.spherebounds;

    vec3 center = sphereBounds.xyz;
    center = (drawCullData.view * vec4(center, 1.f)).xyz;
    float radius = sphereBounds.w;

    bool visible = true;

    // the left/top/right/bottom plane culling utilizes frustum symmetry to cull against two planes at the same time
    visible = visible && center.z * drawCullData.frustum[1] - abs(center.x) * drawCullData.frustum[0] > -radius;
    visible = visible && center.z * drawCullData.frustum[3] - abs(center.y) * drawCullData.frustum[2] > -radius;

    //flip Y because we access depth texture that way
    center.y *= -1;

    if (visible) {
        vec4 aabb;
        if (ProjectSphere(center, radius, drawCullData.znear, drawCullData.P00, drawCullData.P11, aabb)) {
            float width = (aabb.z - aabb.x) * drawCullData.pyramidWidth;
            float height = (aabb.w - aabb.y) * drawCullData.pyramidHeight;

            float level = floor(log2(max(width, height)));

            //            if (level > 9.0) return true;
            //            else return false;

            // Sampler is set up to do min reduction, so this computes the minimum depth of a 2x2 texel quad

            float depth = textureLod(sampler2D(depthPyramid), (aabb.xy + aabb.zw) * 0.5, 0).r;
            float linearDepth = LinearizeDepth(depth);
            if (linearDepth >= 10000.0) return true;
            else return false;
            float depthSphere = (center.z - radius);

            visible = visible && depthSphere <= linearDepth;
        }
    }

    return visible;
    //    if (meshlet.spherebounds.x >= 0) return true;
    //    else return false;
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= meshlets.length()) {
        return;// Prevent out-of-bounds access
    }

    MeshletData meshlet = meshlets[id];

    if (IsVisible(meshlet)) {
        // Write a draw command if the meshlet is visible
        commands[id].primCount = 1;// Adjust according to your needs
    } else {
        // Set draw command count to 0 if the meshlet is not visible
        commands[id].primCount = 0;
    }
}