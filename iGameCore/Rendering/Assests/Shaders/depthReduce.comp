#version 460
//#extension GL_ARB_bindless_texture : require

layout(local_size_x = 16, local_size_y = 16) in;

uniform sampler2DMS inImageMS;
uniform sampler2D inImage;

uniform uint level;
uniform uvec2 inImageSize;
layout(binding = 0, r32f) uniform writeonly image2D outImage;

void main() {
    uvec2 pos = gl_GlobalInvocationID.xy;
    float minDepth = 1.0f;

    if (level == 0) {
        // copy level 0
        if (pos.x >= inImageSize.x || pos.y >= inImageSize.y) return;

        int numSamples = textureSamples(inImageMS);
        for (int i = 0; i < numSamples; ++i) {
            float sampleDepth = texelFetch(inImageMS, ivec2(pos), i).r;
            minDepth = min(minDepth, sampleDepth);
        }
    } else {
        // generate other level
        if (pos.x * 2 >= inImageSize.x || pos.y * 2 >= inImageSize.y) return;
        
        uvec2 pos_0 = pos * 2 + uvec2(0, 0);
        uvec2 pos_1 = pos * 2 + uvec2(0, 1);
        uvec2 pos_2 = pos * 2 + uvec2(1, 0);
        uvec2 pos_3 = pos * 2 + uvec2(1, 1);

        float preLevel = float(level - 1);
        float depth_0 = textureLod(inImage, (vec2(pos_0) + vec2(0.5)) / vec2(inImageSize), preLevel).x;
        float depth_1 = textureLod(inImage, (vec2(pos_1) + vec2(0.5)) / vec2(inImageSize), preLevel).x;
        float depth_2 = textureLod(inImage, (vec2(pos_2) + vec2(0.5)) / vec2(inImageSize), preLevel).x;
        float depth_3 = textureLod(inImage, (vec2(pos_3) + vec2(0.5)) / vec2(inImageSize), preLevel).x;

        // reversed-z buffer
        // depth range: 1.0(near plane) -> 0.0(far plane)
        minDepth = min(min(depth_0, depth_1), min(depth_2, depth_3));
    }

    imageStore(outImage, ivec2(pos), vec4(minDepth));
}