#include "iGameVTKWriter.h"

IGAME_NAMESPACE_BEGIN



bool VTKWriter::GenerateBuffers()
{
	m_Buffers.resize(10, nullptr);
	switch (m_DataObject->GetDataObjectType())
	{
	case IG_SURFACE_MESH:
		m_SurfaceMesh = DynamicCast<SurfaceMesh>(m_DataObject);
		WriteWithSurfaceMeshType();
		break;
	case IG_VOLUME_MESH:
		UnstructuredMesh::TransferVolumeMeshToUnstructuredMesh(DynamicCast<VolumeMesh>(m_DataObject), m_UnstructuredMesh);
		WriteWithUnstructuredMeshType();
		break;
	case IG_UNSTRUCTURED_MESH:
		m_UnstructuredMesh = DynamicCast<UnstructuredMesh>(m_DataObject);
		WriteWithUnstructuredMeshType();
		break;
	case IG_STRUCTURED_MESH:
		m_StructuredMesh = DynamicCast<StructuredMesh>(m_DataObject);
		WriteWithStructuredMeshType();
		break;
	default:
		return false;
	}
<<<<<<< HEAD
=======
	m_Buffers.resize(10, nullptr);
	WriteHeaderToBuffer(m_Buffers[0]);
	WritePointsToBuffer(m_Buffers[1]);
	WriteCellsToBuffer(m_Buffers[2]);
	WriteCellsTypeToBuffer(m_Buffers[3]);
	WritePointsAttributesToBuffer(m_Buffers[4]);
	WriteCellsAttributesToBuffer(m_Buffers[5]);
	return true;
>>>>>>> b2e085d5ae3daee6dabef8068038451a4dedfa47
}
const void VTKWriter::WriteHeaderToBuffer(CharArray::Pointer& buffer)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	std::string data = "# vtk DataFile Version 3.0\nGenerated by iGameMeshLab\n";
	if (m_FileType == IGAME_ASCII) {
		data += "ASCII\nDATASET ";
	}
	else {
		data += "BINARY\nDATASET ";
	}
	switch (m_DataObject->GetDataObjectType())
	{
	case IG_SURFACE_MESH:
		data += "POLYDATA\n";
		break;
	case IG_VOLUME_MESH:
	case IG_UNSTRUCTURED_MESH:
		data += "UNSTRUCTURED_GRID\n";
		break;
	case IG_STRUCTURED_MESH:
		data += "STRUCTURED_GRID\n";
		break;
	default:
		return;
	}
	AddStringToBuffer(data, buffer);
}

const void VTKWriter::WriteWithUnstructuredMeshType()
{
	//后续改成并行计算buffer，只要确保buffer合并顺序不乱就行
	WriteHeaderToBuffer(m_Buffers[0]);
	WritePointsToBuffer(m_UnstructuredMesh->GetPoints(), m_Buffers[1]);
	WriteCellsToBuffer(m_UnstructuredMesh->GetCells(), m_Buffers[2]);
	WriteCellsTypeToBuffer(m_Buffers[3]);
	WritePointsAttributesToBuffer(m_UnstructuredMesh->GetAttributeSet(), m_Buffers[4]);
	WriteCellsAttributesToBuffer(m_UnstructuredMesh->GetAttributeSet(), m_Buffers[5]);
}
const void VTKWriter::WriteWithStructuredMeshType()
{
	//后续改成并行计算buffer，只要确保buffer合并顺序不乱就行
	WriteHeaderToBuffer(m_Buffers[0]);
	WritePointsToBuffer(m_StructuredMesh->GetPoints(), m_Buffers[1]);
	WritePointsAttributesToBuffer(m_StructuredMesh->GetAttributeSet(), m_Buffers[4]);
	WriteCellsAttributesToBuffer(m_StructuredMesh->GetAttributeSet(), m_Buffers[5]);
}
const void VTKWriter::WriteWithSurfaceMeshType()
{
	//后续改成并行计算buffer，只要确保buffer合并顺序不乱就行
	WriteHeaderToBuffer(m_Buffers[0]);
	WritePointsToBuffer(m_SurfaceMesh->GetPoints(), m_Buffers[1]);
	WriteCellsToBuffer(m_SurfaceMesh->GetFaces(), m_Buffers[2]);
	WritePointsAttributesToBuffer(m_SurfaceMesh->GetAttributeSet(), m_Buffers[4]);
	WriteCellsAttributesToBuffer(m_SurfaceMesh->GetAttributeSet(), m_Buffers[5]);

}
const void VTKWriter::WriteDimensionSizeToBuffer(CharArray::Pointer& buffer)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	std::string data = "DIMENSIONS";
	auto dimensionSize = m_StructuredMesh->GetDimensionSize();
	for (int i = 0; i < 3; i++) {
		data += " " + std::to_string(dimensionSize[i]);
	}
	data += '\n';
	AddStringToBuffer(data, buffer);
}

const void VTKWriter::WritePointsToBuffer(Points::Pointer Points, CharArray::Pointer& buffer)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	if (m_DataObject->GetDataObjectType() == IG_STRUCTURED_MESH) {
		WriteDimensionSizeToBuffer(buffer);
	}
	int VertexNum = Points ? Points->GetNumberOfPoints() : 0;
	std::string data = "POINTS " + std::to_string(VertexNum) + " float\n";
	AddStringToBuffer(data, buffer);
	Point p;
	if (m_FileType == IGAME_ASCII) {
		for (int i = 0; i < VertexNum; i++) {
			p = Points->GetPoint(i);
			for (int j = 0; j < 3; j++) {
				if (j)buffer->AddValue(' ');
				data = std::to_string(p[j]);
				AddStringToBuffer(data, buffer);
			}
			buffer->AddValue('\n');
		}
	}
	else {

	}

}
const void VTKWriter::WriteCellsToBuffer(CellArray::Pointer Cells, CharArray::Pointer& buffer)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	int CellNum = Cells ? Cells->GetNumberOfCells() : 0;
	if (!CellNum) {
		return;
	}
	std::string data;
	if (m_DataObject->GetDataObjectType() == IG_SURFACE_MESH) {
		data= "POLYGONS " + std::to_string(CellNum) + ' ';
	}
	else {
		data = "CELLS " + std::to_string(CellNum) + ' ';

	}
	
	size_t idSize = Cells->GetNumberOfCellIds() + Cells->GetNumberOfCells();
	data += std::to_string(idSize) + '\n';
	AddStringToBuffer(data, buffer);
	igIndex vcnt = 0;
	igIndex vhs[IGAME_CELL_MAX_SIZE] = { 0 };
	igIndex cellNum = Cells->GetNumberOfCells();

	if (m_FileType == IGAME_ASCII) {
		for (igIndex i = 0; i < CellNum; i++) {
			vcnt = Cells->GetCellIds(i, vhs);
			data = std::to_string(vcnt);
			AddStringToBuffer(data, buffer);
			for (int j = 0; j < vcnt; j++) {
				buffer->AddValue(' ');
				data = std::to_string(vhs[j]);
				AddStringToBuffer(data, buffer);
			}
			buffer->AddValue('\n');
		}
	}
	else {

	}
}
const void VTKWriter::WriteCellsTypeToBuffer(CharArray::Pointer& buffer)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	auto CellsType = m_UnstructuredMesh->GetCellTypes();
	int CellNum = CellsType ? CellsType->GetNumberOfValues() : 0;
	if (!CellNum)return;
	std::string data = "CELL_TYPES " + std::to_string(CellNum) + '\n';
	AddStringToBuffer(data, buffer);
	igIndex vtkType;
	for (int i = 0; i < CellNum; i++) {
		switch ((int)CellsType->GetValue(i))
		{
		case IG_TRIANGLE:
			vtkType = VTKAbstractReader::TRIANGLE;
			break;
		case IG_QUAD:
			vtkType = VTKAbstractReader::QUAD;
			break;
		case IG_POLYGON:
			vtkType = VTKAbstractReader::POLYGON;
			break;
		case IG_TETRA:
			vtkType = VTKAbstractReader::TETRA;
			break;
		case IG_HEXAHEDRON:
			vtkType = VTKAbstractReader::HEXAHEDRON;
			break;
		case IG_PRISM:
			vtkType = VTKAbstractReader::WEDGE;
			break;
		case IG_PYRAMID:
			vtkType = VTKAbstractReader::PYRAMID;
			break;
		case IG_POLYHEDRON:
			vtkType = VTKAbstractReader::POLYHEDRON;
			break;
		default:
			vtkType = VTKAbstractReader::T0;
			break;
		}
		if (m_FileType == IGAME_ASCII) {
			data = std::to_string(vtkType);
			AddStringToBuffer(data, buffer);
			buffer->AddValue('\n');
		}
		else {

		}
	}
}
const void VTKWriter::WritePointsAttributesToBuffer(AttributeSet::Pointer AttributeSet, CharArray::Pointer& buffer)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	if (AttributeSet == nullptr)return;
	auto PointData = AttributeSet->GetAllPointAttributes();
	if (!PointData || PointData->GetNumberOfElements() == 0)return;
	int VertexNum = m_UnstructuredMesh->GetNumberOfPoints();
	std::string data = "POINT_DATA " + std::to_string(VertexNum) + "\n";
	AddStringToBuffer(data, buffer);
	for (int i = 0; i < PointData->GetNumberOfElements(); i++)
	{
		auto attribute = PointData->GetElement(i);
		auto array = attribute.pointer;
		switch (attribute.type)
		{
		case IG_SCALAR:
			data = "SCALARS " + array->GetName() + " float " + std::to_string(array->GetElementSize()) + "\nLOOKUP_TABLE default\n";
			break;
		case IG_VECTOR:
			data = "VECTORS " + array->GetName() + " float\n";
			break;
		case IG_TENSOR:
			data = "TENSORS " + array->GetName() + " float\n";
			break;
		case IG_NORMAL:
			data = "NORMALS " + array->GetName() + " float\n";
			break;
		default:
			data = "SCALARS ";
			break;
		}
		AddStringToBuffer(data, buffer);
		WriteArrayToBuffer(buffer, array);
	}
	return;
}
const void VTKWriter::WriteCellsAttributesToBuffer(AttributeSet::Pointer AttributeSet, CharArray::Pointer& buffer)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	if (AttributeSet == nullptr)return;
	auto CellData = AttributeSet->GetAllCellAttributes();
	if (!CellData || CellData->GetNumberOfElements() == 0)return;
	int CellNum = CellData->GetElement(0).pointer ? CellData->GetElement(0).pointer->GetNumberOfElements() : 0;
	std::string data = "CELL_DATA " + std::to_string(CellNum) + '\n';
	AddStringToBuffer(data, buffer);
	for (int i = 0; i < CellData->GetNumberOfElements(); i++)
	{
		auto attribute = CellData->GetElement(i);
		auto array = attribute.pointer;
		switch (attribute.type)
		{
		case IG_SCALAR:
			data = "SCALARS " + array->GetName() + " float " + std::to_string(array->GetElementSize()) + "\nLOOKUP_TABLE default\n";
			break;
		case IG_VECTOR:
			data = "VECTORS " + array->GetName() + " float\n";
			break;
		case IG_TENSOR:
			data = "TENSORS " + array->GetName() + " float\n";
			break;
		case IG_NORMAL:
			data = "NORMALS " + array->GetName() + " float\n";
			break;
		default:
			data = "SCALARS ";
			break;
		}
		AddStringToBuffer(data, buffer);
		WriteArrayToBuffer(buffer, array);
	}
}
const void VTKWriter::WriteArrayToBuffer(CharArray::Pointer& buffer, ArrayObject::Pointer array)
{
	if (buffer == nullptr) {
		buffer = CharArray::New();
	}
	int Num = array->GetNumberOfElements();
	int Component = array->GetElementSize();
	//这边先全都默认为float
	float values[16];
	std::string data;
	if (m_FileType == IGAME_ASCII) {
		for (int i = 0; i < Num; i++) {
			array->GetElement(i, values);
			for (int j = 0; j < Component; j++) {
				if (j)buffer->AddValue(' ');
				data = std::to_string(values[j]);
				AddStringToBuffer(data, buffer);
			}
			buffer->AddValue('\n');
		}
	}
	else {

	}
}

IGAME_NAMESPACE_END